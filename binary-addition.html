<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Binary addition - Adventures in Csharp</title><meta name="description" content="Let's take an overview of what just happened. Essentially we add two bytes together. You get that much from the name of the method. The signature of the AddBytes method also tells&hellip;"><meta name="robots" content="index, follow"><meta name="generator" content="Publii Open-Source CMS for Static Site"><link rel="canonical" href="https://Pilvinen.github.io/binary-addition.html"><link rel="alternate" type="application/atom+xml" href="https://Pilvinen.github.io/feed.xml"><link rel="alternate" type="application/json" href="https://Pilvinen.github.io/feed.json"><meta property="og:title" content="Binary addition"><meta property="og:image" content="https://Pilvinen.github.io/media/posts/2/Binary-1920x1280.jpg"><meta property="og:site_name" content="Adventures in Csharp"><meta property="og:description" content="Let's take an overview of what just happened. Essentially we add two bytes together. You get that much from the name of the method. The signature of the AddBytes method also tells&hellip;"><meta property="og:url" content="https://Pilvinen.github.io/binary-addition.html"><meta property="og:type" content="article"><link rel="shortcut icon" href="https://Pilvinen.github.io/media/website/favicon.ico" type="image/x-icon"><link rel="preconnect" href="https://fonts.gstatic.com/" crossorigin><style>h1,h2,h3,h4,h5,h6,.btn,[type=button],[type=submit],button,.navbar .navbar__menu li,.navbar_mobile_sidebar .navbar__menu li,.feed__author,.post__tag,.post__share>a span,.post__nav-link>span,.footer{font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol"}body,h1,.h1,blockquote,.search__input,.author__name,.author__info>p,.feed__item h2,.post__nav-link{font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol"}</style><link rel="stylesheet" href="https://Pilvinen.github.io/assets/css/style.css?v=2c4fe628aea2f72a9930ec5f6565c687"><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://Pilvinen.github.io/binary-addition.html"},"headline":"Binary addition","datePublished":"2020-10-28T23:12","dateModified":"2020-10-28T23:25","image":{"@type":"ImageObject","url":"https://Pilvinen.github.io/media/posts/2/Binary-1920x1280.jpg","height":1280,"width":1920},"description":"Let's take an overview of what just happened. Essentially we add two bytes together. You get that much from the name of the method. The signature of the AddBytes method also tells&hellip;","author":{"@type":"Person","name":"Pilvinen"},"publisher":{"@type":"Organization","name":"Pilvinen","logo":{"@type":"ImageObject","url":"https://Pilvinen.github.io/media/website/Hedgehog.png","height":397,"width":640}}}</script><script src="https://Pilvinen.github.io/assets/js/ls.parent-fit.min.js?v=1c78585e2a70398fe95085061942fd37"></script><script async src="https://Pilvinen.github.io/assets/js/lazysizes.min.js?v=149ff45fc6c2f13e892e438a58abb77f"></script></head><body><div class="site-container"><header class="top" id="js-header"><a class="logo" href="https://Pilvinen.github.io/"><img src="https://Pilvinen.github.io/media/website/Hedgehog.png" alt="Adventures in Csharp"></a></header><main><article class="post"><div class="hero"><figure class="hero__image"><img class="hero__image-img lazyload" data-src="https://Pilvinen.github.io/media/posts/2/Binary-1920x1280.jpg" data-srcset="https://Pilvinen.github.io/media/posts/2/responsive/Binary-1920x1280-xs.jpg 300w ,https://Pilvinen.github.io/media/posts/2/responsive/Binary-1920x1280-sm.jpg 480w ,https://Pilvinen.github.io/media/posts/2/responsive/Binary-1920x1280-md.jpg 768w ,https://Pilvinen.github.io/media/posts/2/responsive/Binary-1920x1280-lg.jpg 1024w ,https://Pilvinen.github.io/media/posts/2/responsive/Binary-1920x1280-xl.jpg 1360w ,https://Pilvinen.github.io/media/posts/2/responsive/Binary-1920x1280-2xl.jpg 1600w" data-aspectratio="1.5" data-sizes="auto" alt="Binary" height="1280" width="1920"></figure><header class="hero__content"><div class="wrapper"><div class="post__meta"><time datetime="2020-10-28T23:12">October 28, 2020</time></div><h1>Binary addition</h1><div class="post__meta post__meta--author"><img class="lazyload post__author-thumb" data-src="https://Pilvinen.github.io/media/website/Pilvinen.jpg" alt="Pilvinen"> <a href="https://Pilvinen.github.io/authors/pilvinen/" class="feed__author invert">Pilvinen</a></div></div></header></div><div class="wrapper post__entry"><figure class="post__image"><img class="lazyload" data-src="https://Pilvinen.github.io/media/posts/2/Binary_addition.jpg" data-sizes="auto" data-srcset="https://Pilvinen.github.io/media/posts/2/responsive/Binary_addition-xs.jpg 300w ,https://Pilvinen.github.io/media/posts/2/responsive/Binary_addition-sm.jpg 480w ,https://Pilvinen.github.io/media/posts/2/responsive/Binary_addition-md.jpg 768w ,https://Pilvinen.github.io/media/posts/2/responsive/Binary_addition-lg.jpg 1024w ,https://Pilvinen.github.io/media/posts/2/responsive/Binary_addition-xl.jpg 1360w ,https://Pilvinen.github.io/media/posts/2/responsive/Binary_addition-2xl.jpg 1600w" alt="" data-aspectratio="2.250000" width="513" height="228"></figure><p>Let's take an overview of what just happened.</p><p>Essentially we <strong>add</strong> two bytes together. You get that much from the name of the method.</p><p>The signature of the <strong>AddBytes</strong> method also tells us that it takes in two <strong>bytes</strong>, <strong>a</strong> and <strong>b</strong> as parameters, and returns a <strong>byte</strong> which contains the result of the addition.</p><p>Inside the method we loop until <strong>b</strong> is zero. Inside the while loop we <strong>AND</strong> (<strong>&amp;</strong>), then we <strong>XOR</strong> (<strong>^</strong>), and finally we <strong>left shift</strong> (<strong>&lt;&lt;</strong>) by one.</p><p>And, apparently, as a result we get two binary numbers added together nicely, just like in our everyday base-10, where we could calculate something like <code>2 + 2 = 4</code> </p><p>So why does the above piece of code work and do what it does? Let's break it down and make it simple.</p><p>The first operation inside the while loop is storing temporarily in <strong>carryBits</strong> variable the result of the bitwise <strong>AND</strong> (<strong>&amp;</strong>) operation between a and b, ie:</p><pre><code>var carryBits = (byte) (a &amp; b);</code></pre><p>There's a little bit of casting going on here through and through because C# doesn't support performing bitwise operations directly on the actual <code>byte</code> type, it converts them for the bitwise operations. You could also perform these operations on the <code>int</code> type, for example, in which case you would have:</p><pre><code>var carryBits = a &amp; b;</code></pre><p>Don't get distracted by the casting.</p><p>So, we're carrying bits. But what is carrying? Let's take a quick refresher on carrying in math. Carrying is just like in normal everyday addition:</p><pre><code>   122</code><br><code>+  921</code><br><code>= 1043</code></pre><p>Where you add the numbers together which are on top of each other and you combine them at the bottom for the final result. You have the ones, you have the tens, you have the hundreds, and you have the thousands. In the same way in binary you have the ones, you have the twos, you have the fours, you have the eights, and so on. It's just base-2 (0, and 1) instead of base-10 (0, 1, 2, 3, 4, 5, 6, 7, 8, and 9).</p><p>In the above example carrying happens when you add the one hundred and nine hundred together, you carry the one to the thousands and in hundreds you then have a zero because <code>100 + 900</code> doesn't leave a remainder in the hundreds. If you had <code>100 + 1100</code> instead you  would add the thousands: <code>0 * 1000 + 1 * 1000 = 1000</code>, and then you would add the hundreds: <code>1 * 100 + 1 * 100 = 200</code>. And finally you would add all the different values together (no more carrying to process) and you'd end up with a total of 1200.</p><p>So carrying happens when you add two numbers together (for example <code>9 + 9</code>) and they don't fit in the scale (in this case the ones) and you have to move, ie. you'd have to carry, the overflow to the tens. You'd end up with 18.</p><p>In binary it works in exactly the same way. When you get overflow from addition you move it up, you carry it over.</p><p>The only differences are that in binary you, usually, go from right to left, and 0 means that the value isn't set, and 1 means the value is set. Therefore:</p><pre><code>1101</code></pre><p>Simply means, from right to left:t 1 * 1 + 0 * 2 + 1 * 4 + 1 * 8. From right to left -&gt; ones (set), twos (not set), fours (set), eights (set). Giving us the total of 13 in our every day base-10.</p><pre><code>var a = (byte) 0b_0101; // (This is a "binary literal" in C#)</code><br><code>var b = (byte) 0b_0110;</code><br><code>var carryBits = (byte) (a &amp; b);</code></pre><p>So, when we do a bitwise AND operation, like <code>0101 &amp; 0110</code>(as shown in the above example) simply imagine in your head that you place the numbers on top of each other like in regular base-10 calculus:</p><pre><code>  0101</code><br><code>&amp; 0110</code><br><code>= 0100</code></pre><p>The bitwise AND operation returns 1 only when the two overlapping binary numbers are both 1. For all other binary values it returns 0.</p><p>So why are we doing this and storing the result in <code>carryBits</code>? Because it's exactly the same as when you add <code>100 + 900</code>, you know you need to carry the hundreds into thousands, except now you need to carry the overflowing bits. Now we know that there are overlapping values, and when we add them together we will need to carry this bit position to the next one.</p><p>It should be starting to make sense now. Let's move on.</p><pre>a = (byte) (a ^ b);</pre><p>Here we are storing the result of an <strong>XOR</strong> (<strong>^</strong>) operation between a and b in the <strong>a</strong>. We are basically <em>simulating addition</em> with XOR.</p><p>What XOR does is:</p><pre>  0101<br>^ 0110<br>= 0011</pre><p> It returns 1 only when the two bits that are being compared are different from each other.</p><p>We have already safely stored the overflowing bits in the temporary <code>carryBits</code>and now we have copied the rest of the bits which are <em>not</em> overflowing (no need to carry anything) to <strong>a</strong>.</p><p>We can now perform the final bitwise operation which is the <strong>left bitshift</strong>. What left bitshift does is that it simply moves all the bits left by whatever number you want to move them. For example:</p><pre>var a = (byte) 0b_0001; // a is 0001<br>a = a &lt;&lt; 1;             // a is 0010<br>a = a &lt;&lt; 1;             // a is 0100<br>a = a &lt;&lt; 1;             // a is 1000<br>a = a &lt;&lt; 1;             // a is 0000</pre><p>In the final left bitshift operation we lose our data. By default we get behavior which simply drops overflowing bits - you lose them, they are gone.</p><p>And if you move it by two:</p><pre>var a = (byte) 0b_0001; // a is 0001<br>a = a &lt;&lt; 2;             // a is 0100</pre><p> The bits are simply shifted left by two positions.</p><p>By now you might be starting to realize "Wait... but what if I have an overflow, carry bit, at position like:</p><pre>  1000</pre><p>Where there is nowhere to go?" </p><p>That's right. In that kind of situations you would get an incorrect answer from bitwise binary addition. For simplicity's sake this article doesn't show you how to handle situations like that where you actually run out of space from your value type. It can be handled, but the code gets much more complex and is therefore not a very good place to show the basic principles of binary bitwise addition and is therefore out of the scope of this article.</p><pre>b = (byte) (carryBits &lt;&lt; 1);</pre><p>Now that you understand what a left bitshift does, it's not hard to see what's going on here. We're simply <em>moving the carry bits</em>, the overflowing bits, one step further in the scale of numbers. One becomes two, two becomes four, and so on.</p><p>We assign the result into <strong>b</strong>, all the numbers in b just moved one step left. The while loop is now ready for another round until there are no more <code>1</code> bits left in <strong>b</strong>.</p><p>When b is zero we're ready to exit the while-loop and return <strong>a</strong> where we have shifted, combined, and shuffled all of our bits iteration by iteration. We're moving and fitting everything together in a nice and orderly line of bits.</p><p>Logic! There's nothing better.</p><p>If you don't understand binary addition straight away by simply reading this article, don't fret. There's hope for you yet. It's like driving a bicycle. You don't learn how to drive by simply reading a manual. Once you understand the basic principles of binary bitwise operations you have to play with them, and experiment with them.</p><p>That's how you learn.</p></div><footer class="wrapper post__footer"><p class="post__last-updated">This article was updated on October 28, 2020</p><ul class="post__tag"><li><a href="https://Pilvinen.github.io/binary/">Binary</a></li><li><a href="https://Pilvinen.github.io/bitwise/">Bitwise</a></li><li><a href="https://Pilvinen.github.io/c/">C#</a></li><li><a href="https://Pilvinen.github.io/csharp/">Csharp</a></li></ul><div class="post__share"></div><div class="post__bio bio"><img class="lazyload bio__avatar" data-src="https://Pilvinen.github.io/media/website/Pilvinen.jpg" alt="Pilvinen"><div class="bio__info"><h3 class="bio__name"><a href="https://Pilvinen.github.io/authors/pilvinen/" class="invert" rel="author">Pilvinen</a></h3><p>Star and Serpent indie game studio founder and game designer. Working on Rituals of the old PC sandbox RPG voxel game.</p></div></div></footer></article><nav class="post__nav"><div class="post__nav-inner"><div class="post__nav-prev"><svg width="1.041em" height="0.416em" aria-hidden="true"><use xlink:href="https://Pilvinen.github.io/assets/svg/svg-map.svg#arrow-prev"/></svg> <a href="https://Pilvinen.github.io/array-flattening.html" class="invert post__nav-link" rel="prev"><span>Previous</span> Array flattening</a></div></div></nav></main><footer class="footer"><div class="footer__copyright"><a href="https://www.starandserpent.com" target="_blank" rel="noopener noreferrer">https://www.starandserpent.com</a></div><button class="footer__bttop js-footer__bttop" aria-label="Back to top"><svg><title>Back to top</title><use xlink:href="https://Pilvinen.github.io/assets/svg/svg-map.svg#toparrow"/></svg></button></footer></div><script>window.publiiThemeMenuConfig = {    
        mobileMenuMode: 'sidebar',
        animationSpeed: 300,
        submenuWidth: 'auto',
        doubleClickTime: 500,
        mobileMenuExpandableSubmenus: true, 
        relatedContainerForOverlayMenuSelector: '.top',
   };</script><script defer="defer" src="https://Pilvinen.github.io/assets/js/scripts.min.js?v=f56b13ba141d95ea2a0b7aab75ca9528"></script><script>var lazyFeaturedImage=function lazyFeaturedImage(){var b=document.querySelectorAll(".hero__image-img");for(var a=0;a<b.length;a++){var c=b[a];c.addEventListener("lazyloaded",function(f){var d=f.target.parentNode;d.classList.add("hero__image--overlay")})}};lazyFeaturedImage();</script></body></html>